<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Mode Switch | Dataism Style</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #050505;
            --secondary-color: #ff00ff; /* Magenta */
            --primary-color: #00f3ff;   /* Cyan */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-user-select: none;
        }
        
        /* 允许输入框被选中和编辑 */
        input {
            user-select: auto !important;
            -webkit-user-select: auto !important;
        }

        body {
            background-color: var(--bg-color);
            color: #fff;
            font-family: 'Space Grotesk', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            cursor: grab;
            position: relative;
        }
        
        .canvas-container:active {
            cursor: grabbing;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* 渐隐遮罩 */
        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: linear-gradient(90deg, 
                var(--bg-color) 0%, 
                transparent 20%, 
                transparent 80%, 
                var(--bg-color) 100%
            );
            z-index: 10;
        }
        
        /* 切换按钮区域 */
        .ui-layer {
            position: absolute;
            top: 2rem;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 30;
            pointer-events: none;
        }

        .toggle-container {
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 1rem;
            background: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(10px);
            padding: 0.5rem 1rem;
            border-radius: 50px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .toggle-label {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.6);
            font-weight: 500;
        }
        
        .toggle-label.active {
            color: #fff;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        /* 开关样式 */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #333;
            transition: .4s;
            border-radius: 34px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--secondary-color);
            box-shadow: 0 0 15px var(--secondary-color);
        }

        input:checked + .slider:before {
            transform: translateX(24px);
        }

        /* 提示文字 */
        .hint {
            position: absolute;
            bottom: 2rem;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.9rem;
            letter-spacing: 1px;
            pointer-events: none;
            z-index: 20;
        }

        /* 浮动输入框 */
        #editInput {
            position: absolute;
            display: none;
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid var(--secondary-color);
            color: #fff;
            font-family: 'Space Grotesk', 'PingFang SC', sans-serif;
            font-weight: bold;
            text-align: center;
            border-radius: 4px;
            outline: none;
            z-index: 100;
            padding: 0 5px;
            margin: 0;
            transform: translate(0, -50%); /* 垂直居中，水平靠右对齐锚点 */
            pointer-events: auto; /* 确保可点击 */
            box-shadow: 0 0 10px var(--secondary-color);
        }
    </style>
</head>
<body>

    <div class="ui-layer">
        <div class="toggle-container">
            <span class="toggle-label active" id="label-num">数值模式</span>
            <label class="switch">
                <input type="checkbox" id="modeSwitch">
                <span class="slider"></span>
            </label>
            <span class="toggle-label" id="label-game">游戏模式</span>
        </div>
    </div>

    <div class="canvas-container" id="container">
        <canvas id="canvas"></canvas>
        <div class="vignette"></div>
        <input type="text" id="editInput">
    </div>
    
    <div class="hint">拖动圆点 (0-10) · 点击变量名编辑 · 拖动背景平移</div>

    <script>
        const GAMES = [
            "扫雷", 
            "2048", 
            "开心消消乐", 
            "俄罗斯方块", 
            "贪吃蛇",
            "推箱子", 
            "连连看", 
            "泡泡龙", 
            "祖玛", 
            "黄金矿工",
            "植物大战僵尸"
        ];
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('container');
        const modeSwitch = document.getElementById('modeSwitch');
        const labelNum = document.getElementById('label-num');
        const labelGame = document.getElementById('label-game');
        const editInput = document.getElementById('editInput');

        // 状态变量
        let currentX = 5.0; 
        let viewOffsetX = 0;
        let isGameMode = false;
        let variableName = "x"; // 变量名，可编辑
        
        // 拖拽与交互状态
        let isDraggingPoint = false;
        let isDraggingView = false;
        let isEditing = false;
        let lastPointerX = 0;
        
        // 记录可点击区域
        let lastLabelRect = { x: 0, y: 0, w: 0, h: 0 };
        
        // 布局与配置
        let width, height, originY;
        const CONFIG = {
            scale: 150, 
            minVal: 0,
            maxVal: 10,
            pointRadius: 10,
            hitRadius: 30,
            axisColor: '#ffffff',
            dimColor: 'rgba(255, 255, 255, 0.1)',
            gridColor: 'rgba(255, 255, 255, 0.04)',
            mainColor: '#ff00ff', // 洋红色
            textColor: '#ffffff'
        };

        function init() {
            resize();
            window.addEventListener('resize', resize);
            
            // 鼠标/触摸事件
            container.addEventListener('mousedown', onPointerDown);
            window.addEventListener('mousemove', onPointerMove);
            window.addEventListener('mouseup', onPointerUp);
            
            container.addEventListener('touchstart', onPointerDown, {passive: false});
            window.addEventListener('touchmove', onPointerMove, {passive: false});
            window.addEventListener('touchend', onPointerUp);
            
            // 切换开关
            modeSwitch.addEventListener('change', (e) => {
                isGameMode = e.target.checked;
                if (isGameMode) {
                    labelGame.classList.add('active');
                    labelNum.classList.remove('active');
                    currentX = Math.round(currentX);
                } else {
                    labelGame.classList.remove('active');
                    labelNum.classList.add('active');
                }
                draw();
            });
            
            // 输入框事件 - 阻止冒泡非常重要
            editInput.addEventListener('mousedown', (e) => e.stopPropagation());
            editInput.addEventListener('touchstart', (e) => e.stopPropagation());
            
            editInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') finishEditing();
                if (e.key === 'Escape') cancelEditing();
                e.stopPropagation();
            });
            editInput.addEventListener('blur', finishEditing);
            
            centerViewOn(currentX);
        }

        function resize() {
            width = container.clientWidth;
            height = container.clientHeight;
            
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            
            originY = height / 2;
            draw();
        }

        function centerViewOn(val) {
            viewOffsetX = (width / 2) - (val * CONFIG.scale);
            draw();
        }

        function valToCanvas(val) {
            return (val * CONFIG.scale) + viewOffsetX;
        }

        function canvasToVal(xPx) {
            return (xPx - viewOffsetX) / CONFIG.scale;
        }

        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        // 开始编辑变量名
        function startEditing() {
            if (isEditing) return; // 防止重复触发
            isEditing = true;
            isDraggingPoint = false;
            isDraggingView = false; // 确保不处于拖拽背景状态
            
            // 设置输入框样式
            editInput.style.fontSize = '24px';
            editInput.style.height = '34px';
            
            // 计算文字宽度以调整输入框宽度
            ctx.font = "bold 24px 'Space Grotesk', 'PingFang SC', sans-serif";
            const metrics = ctx.measureText(variableName);
            const inputW = Math.max(60, metrics.width + 30);
            editInput.style.width = inputW + 'px';
            
            // 定位：垂直居中
            const centerY = lastLabelRect.y + lastLabelRect.h / 2;
            
            // 确保输入框位置准确
            editInput.style.left = lastLabelRect.x + 'px';
            editInput.style.top = centerY + 'px';
            editInput.style.transform = 'translate(0, -50%)'; 
            
            editInput.value = variableName;
            editInput.style.display = 'block';
            
            // 延时聚焦，确保 display: block 生效
            requestAnimationFrame(() => {
                editInput.focus();
                editInput.select();
            });
        }

        function finishEditing() {
            if (!isEditing) return;
            isEditing = false;
            editInput.style.display = 'none';
            
            const val = editInput.value.trim();
            if (val) {
                variableName = val;
            }
            draw();
        }

        function cancelEditing() {
            isEditing = false;
            editInput.style.display = 'none';
            draw();
        }

        function onPointerDown(e) {
            // 如果正在编辑，点击别处会触发 blur -> finishEditing
            if (isEditing) return;

            const { x, y } = getPointerPos(e);
            
            // 1. 检测是否点击了左侧标签 (x =)
            // 大幅扩大判定范围，确保容易点中
            const pad = 20; 
            if (x >= lastLabelRect.x - pad && x <= lastLabelRect.x + lastLabelRect.w + pad &&
                y >= lastLabelRect.y - pad && y <= lastLabelRect.y + lastLabelRect.h + pad) {
                e.preventDefault(); // 防止触发其他默认行为
                startEditing();
                return;
            }

            lastPointerX = x;
            
            // 2. 检测是否点击了圆点
            const pointCx = valToCanvas(currentX);
            const pointCy = originY;
            const dist = Math.sqrt((x - pointCx)**2 + (y - pointCy)**2);
            
            if (dist < CONFIG.hitRadius * 1.5) {
                isDraggingPoint = true;
                container.style.cursor = 'grabbing';
            } else {
                isDraggingView = true;
                container.style.cursor = 'grabbing';
            }
        }

        function onPointerMove(e) {
            if (isEditing) return;

            const { x, y } = getPointerPos(e);
            
            // 悬停提示
            // 检查标签
            const pad = 20;
            if (x >= lastLabelRect.x - pad && x <= lastLabelRect.x + lastLabelRect.w + pad &&
                y >= lastLabelRect.y - pad && y <= lastLabelRect.y + lastLabelRect.h + pad) {
                container.style.cursor = 'text'; // 明确的文本输入光标
                return;
            }

            const pointCx = valToCanvas(currentX);
            const pointCy = originY;
            const dist = Math.sqrt((x - pointCx)**2 + (y - pointCy)**2);
            
            if (!isDraggingPoint && !isDraggingView) {
                if (dist < CONFIG.hitRadius * 1.5) {
                    container.style.cursor = 'grab';
                } else {
                    container.style.cursor = 'grab';
                }
            }
            
            if (isDraggingPoint || isDraggingView) {
                e.preventDefault();
                const deltaX = x - lastPointerX;
                
                if (isDraggingPoint) {
                    let newVal = canvasToVal(x);
                    newVal = Math.max(CONFIG.minVal, Math.min(CONFIG.maxVal, newVal));
                    
                    const rounded = Math.round(newVal);
                    const magnetStrength = isGameMode ? 0.35 : 0.15;
                    if (Math.abs(newVal - rounded) < magnetStrength) {
                        newVal = rounded;
                    }
                    
                    currentX = newVal;
                    
                    const screenEdgeBuffer = 80;
                    if (x < screenEdgeBuffer) {
                        viewOffsetX += 8;
                    } else if (x > width - screenEdgeBuffer) {
                        viewOffsetX -= 8;
                    }
                } else if (isDraggingView) {
                    viewOffsetX += deltaX;
                }
                
                lastPointerX = x;
                draw();
            }
        }

        function onPointerUp() {
            if (isEditing) return;
            isDraggingPoint = false;
            isDraggingView = false;
            container.style.cursor = 'grab';
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);
            drawGrid();
            drawAxisLines();
            drawPointAndLabel(currentX);
        }

        function drawGrid() {
            const startVal = Math.floor(canvasToVal(0));
            const endVal = Math.ceil(canvasToVal(width));

            ctx.lineWidth = 1;
            ctx.strokeStyle = CONFIG.gridColor;
            
            ctx.beginPath();
            for (let i = startVal; i <= endVal; i++) {
                const x = valToCanvas(i);
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
            }
            ctx.stroke();
        }
        
        function drawAxisLines() {
            ctx.beginPath();
            ctx.strokeStyle = CONFIG.dimColor;
            ctx.lineWidth = 2;
            ctx.moveTo(0, originY);
            ctx.lineTo(width, originY);
            ctx.stroke();
            
            const x0 = valToCanvas(CONFIG.minVal);
            const x10 = valToCanvas(CONFIG.maxVal);
            
            ctx.beginPath();
            ctx.strokeStyle = CONFIG.axisColor;
            ctx.lineWidth = 2;
            ctx.shadowBlur = 5;
            ctx.shadowColor = 'rgba(255,255,255,0.5)';
            ctx.moveTo(Math.max(x0, -10), originY);
            ctx.lineTo(Math.min(x10, width + 10), originY);
            ctx.stroke();
            ctx.shadowBlur = 0;

            const startVisible = Math.floor(canvasToVal(0));
            const endVisible = Math.ceil(canvasToVal(width));
            const loopStart = Math.max(startVisible, CONFIG.minVal - 1);
            const loopEnd = Math.min(endVisible, CONFIG.maxVal + 1);

            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.font = '14px Space Grotesk';

            for (let i = loopStart; i <= loopEnd; i++) {
                const x = valToCanvas(i);
                const isMainRange = i >= CONFIG.minVal && i <= CONFIG.maxVal;
                
                ctx.beginPath();
                if (isMainRange) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                } else {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                }
                
                ctx.moveTo(x, originY - 8);
                ctx.lineTo(x, originY + 8);
                ctx.stroke();

                const showLabel = true;
                if (showLabel) {
                    if (isMainRange) {
                        ctx.fillText(i, x, originY + 18);
                    }
                }
            }
            
            ctx.strokeStyle = CONFIG.mainColor;
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.moveTo(x0, originY - 12);
            ctx.lineTo(x0, originY + 12);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(x10, originY - 12);
            ctx.lineTo(x10, originY + 12);
            ctx.stroke();
        }

        function drawPointAndLabel(val) {
            const cx = valToCanvas(val);
            const cy = originY;
            
            const labelHeight = 70;
            const labelY = cy - labelHeight;

            // 连接线
            ctx.beginPath();
            ctx.strokeStyle = CONFIG.mainColor;
            ctx.lineWidth = 2;
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx, labelY + 28);
            ctx.stroke();

            // 圆点
            ctx.beginPath();
            ctx.fillStyle = CONFIG.mainColor;
            ctx.shadowBlur = 15;
            ctx.shadowColor = CONFIG.mainColor;
            ctx.arc(cx, cy, CONFIG.pointRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.beginPath();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.arc(cx, cy, CONFIG.pointRadius + 4, 0, Math.PI * 2);
            ctx.stroke();

            // ---------------------
            // 方框绘制
            // ---------------------
            let displayText = "";
            let subText = "";
            
            if (isGameMode) {
                const idx = Math.round(val);
                displayText = GAMES[idx] || `游戏 #${idx}`;
                subText = `索引: ${idx}`;
            } else {
                displayText = val.toFixed(1).replace(/[.,]0$/, '');
                subText = "数值";
            }

            const mainFontSize = isGameMode ? 32 : 48;
            ctx.font = `bold ${mainFontSize}px 'Space Grotesk', 'PingFang SC', sans-serif`;
            
            const textMetrics = ctx.measureText(displayText);
            let boxW = textMetrics.width + 50;
            if (boxW < 140) boxW = 140;
            
            const boxH = 70;
            const boxX = cx - boxW / 2;
            const boxYPos = labelY - boxH;

            // 方框背景
            ctx.fillStyle = 'rgba(20, 20, 20, 0.85)';
            ctx.strokeStyle = CONFIG.mainColor;
            ctx.lineWidth = 2;
            
            ctx.shadowBlur = 10;
            ctx.shadowColor = CONFIG.mainColor;
            
            roundRect(ctx, boxX, boxYPos, boxW, boxH, 6);
            ctx.fill();
            ctx.stroke();
            ctx.shadowBlur = 0;

            // ---------------------
            // 绘制内容
            // ---------------------
            ctx.textBaseline = 'middle';
            
            // 1. 绘制左侧的 x = (现在是变量名，可编辑)
            ctx.font = "bold 24px 'Space Grotesk', 'PingFang SC', sans-serif";
            const labelText = variableName + " =";
            const labelMetrics = ctx.measureText(labelText);
            
            // 定位：方框左侧 15px 处结束
            const labelRightX = boxX - 15;
            const labelLeftX = labelRightX - labelMetrics.width;
            
            // 绘制文字背景以便看清
            // ctx.fillStyle = "red";
            // ctx.fillRect(labelLeftX, boxYPos + boxH/2 - 15, labelMetrics.width, 30);
            
            // 给可编辑文字加个下划线或颜色提示
            ctx.fillStyle = "#ffffff";
            ctx.textAlign = "right";
            
            // 绘制发光效果提示可编辑
            ctx.shadowBlur = 5;
            ctx.shadowColor = "rgba(255,255,255,0.5)";
            ctx.fillText(labelText, labelRightX, boxYPos + boxH/2);
            ctx.shadowBlur = 0;
            
            // 绘制下划虚线
            ctx.beginPath();
            ctx.strokeStyle = "rgba(255,255,255,0.3)";
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            ctx.moveTo(labelLeftX, boxYPos + boxH/2 + 14);
            ctx.lineTo(labelRightX, boxYPos + boxH/2 + 14);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // 记录点击区域 (大幅加宽)
            lastLabelRect = {
                x: labelLeftX,
                y: boxYPos + boxH/2 - 20,
                w: labelMetrics.width,
                h: 40
            };

            // 2. 绘制方框内的数字/游戏名
            ctx.textAlign = 'center';
            ctx.font = `bold ${mainFontSize}px 'Space Grotesk', 'PingFang SC', sans-serif`;
            
            ctx.shadowBlur = 15;
            ctx.shadowColor = CONFIG.mainColor;
            ctx.fillStyle = CONFIG.mainColor;
            
            ctx.fillText(displayText, cx, boxYPos + boxH/2 + 2);
            ctx.shadowBlur = 0;
            
            if (isGameMode) {
                ctx.font = '12px "PingFang SC", sans-serif';
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.fillText(subText, cx, boxYPos + boxH + 16);
            }
        }

        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        init();
    </script>
</body>
</html>